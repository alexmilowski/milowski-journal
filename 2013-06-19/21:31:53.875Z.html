<article xmlns="http://www.w3.org/1999/xhtml" vocab="http://schema.org/" typeof="BlogPosting" resource="http://www.milowski.com/journal/entry/2013-06-19T21:31:53.875Z">
<script type="application/json+ld">
{
"@context" : "http://schema.org/",
"@id" : "http://www.milowski.com/journal/entry/2013-06-19T21:31:53.875Z",
"headline" : "Managing Documents in MarkLogic with XProc",
"datePublished" : "2013-06-19T21:31:53.875Z",
"dateModified" : "2013-06-19T21:31:53.875Z",
"keywords" : ["XProc","MarkLogic","XQuery","big data","Calabash","MLD Approach"],
"author" : [ { "@type" : "Person", "name" : "Alex Miłowski" }]
}
</script>
<h1>Managing Documents in MarkLogic with XProc</h1>
<h3>Summary</h3>
<p>The * “many little documents” (MLD) approach * has the consequence of needing to manage massive numbers of individual documents.  XProc is an invaluable tool for managing documents and solving problems encountered with the <em>MLD approach</em> .  This rather long post will step through the problem and how you can solve it with a combination of <a href="http://www.w3.org/TR/XProc">XProc</a> and <a href="http://www.w3.org/TR/xquery/">XQuery</a> for <a href="http://www.marklogic.com/">MarkLogic</a> .</p>
<h3>The Problem</h3>
<p>One of the problems with the * “many little documents” (MLD) approach * to big data is that you end up with millions of documents to manage.  In my particular case, each day I receive about 1.5 million weather reports and each is stored as a separate document.  This gives my import and other process the wonderful property of idempotence but it does end up costing me in other ways:</p>
<ul>
<li>It is pointless to enable a document URI lexicon in MarkLogic as it would end up being massive and costly.</li>
<li>Without a document URI lexicon, address documents by a constructed URI is less efficient.</li>
<li>Manipulating a day or month's worth of data means handling a lot of documents all at once.</li>
<li>Handling individual documents often means addressing them by URI.</li>
</ul>
<p>Also, because of the experimental nature of my research, I don't intend on keeping a full archive of the <a href="http://wxqa.com/">CWOP weather data</a> and the time has come to cull months from the database that I don't need and can't afford to store.  In general, my server can support 3-4 months of data before I need more disk space or possibly more memory.</p>
<p>So, the task at hand is to delete several months worth of data.  Sounds simple, right?  Remember, each month represents 45 million documents whose access by URI isn't preferred.  As such, finding and deleting weather report document by a simple query can be expensive:</p>
<pre><code>declare namespace s=&quot;http://weather.milowski.com/V/APRS/&quot;;
let $dtstart := xs:dateTime(&quot;2013-01-01T00:00:00Z&quot;),
    $dtend := xs:dateTime(&quot;2013-02-01T00:00:00Z&quot;)
   for $r in collection(&quot;http://weather.milowski.com/weather/&quot;)/s:report[@received&gt;=$dtstart and @received&lt;$dtend]
      return xdmp:document-delete(base-uri($r))

</code></pre>
<p>That's an iteration over 45+ million documents and so we expect that to be very, very slow.  In fact, it will most certainly timeout on the server and nothing will actually get deleted.</p>
<p>For any problem like this, we need to divide the task into reasonable sized smaller tasks which the server can complete within the allocated time limit. With the <em>MLD approach</em> , we need to rely on the organization of the documents.  That is, deleting collections or directories is very fast in comparison to deleting each document individually.</p>
<p>Unfortunately for me, I didn't organize my weather data by time periods like days or months.  Instead, I organized it by metadata like station identifier.  As such, I have no way to easily delete my data by month and so the first task is to organize my data.</p>
<h3>XProc to the Rescue!</h3>
<p>Fortunately, technologies like <a href="http://www.w3.org/TR/XProc">XProc</a> exist and have easy ways to interact with <a href="http://www.marklogic.com/">MarkLogic</a> .  In fact, <a href="http://xmlcalabash.com/">Calabash</a> ships with MarkLogic specific steps that let me send adhoc queries to the server.  This allows me to poke at data or, in this case, delete documents.</p>
<p>In my testing, empirical evidence suggests that I can delete a day's worth (1.5 million documents) easily within the transaction time limit.  All I need to do is create collections for each day, assign the appropriate weather report documents to those collections, and then we're ready to delete.   That does mean we need to iterate through each day's worth of documents.</p>
<p>Iterating 1.5+ million documents in a single transaction is still a bad idea even though adjusting metadata (e.g. collections that they belong to) is reasonably fast.  As such, we need to group documents into even smaller partitions (e.g. 1 hour segments) and process them as separate transactions.  That results in a more reasonable number of about 62,000 documents per transaction.</p>
<p>The strategy for the processing is simple:</p>
<ul>
<li>The input is a requested month and day range.</li>
<li>From the input, generate the explicit set of day/hour partitions to process.</li>
<li>For each partition, run a <strong>separate</strong> query transaction against the server that assigns the documents to the collections.</li>
</ul>
<p>The input can be embedded within the pipeline to make it easier to run.  We'll also pass in all the server information as parameters.  The pipeline starts as follows:</p>
<pre><code>
&lt;p:declare-step 
   xmlns:p=&quot;http://www.w3.org/ns/xproc&quot;
   xmlns:c=&quot;http://www.w3.org/ns/xproc-step&quot; 
   xmlns:ml=&quot;http://xmlcalabash.com/ns/extensions/marklogic&quot;
   xmlns:cx=&quot;http://xmlcalabash.com/ns/extensions&quot;    
   version=&quot;1.0&quot;&gt;
   &lt;p:option name='xdb.user'/&gt;
   &lt;p:option name='xdb.password'/&gt;
   &lt;p:option name='xdb.host'/&gt;
   &lt;p:option name='xdb.port'/&gt;
   &lt;p:input port=&quot;source&quot;&gt;
      &lt;p:inline&gt;
         &lt;request month=&quot;2013-01&quot; start=&quot;1&quot; end=&quot;31&quot;/&gt;
      &lt;/p:inline&gt;
   &lt;/p:input&gt;
   &lt;p:output port=&quot;result&quot;/&gt;
   &lt;p:import href=&quot;http://xmlcalabash.com/extension/steps/library-1.0.xpl&quot;/&gt;
  ...

</code></pre>
<p>Note how we are importing the Calabash extension steps and using declaring the namespace for the MarkLogic steps.  We'll use that later.</p>
<p>Next, we use the local XQuery processor to generate each day as a separate <code>group</code> element:</p>
<pre><code>
   &lt;p:xquery&gt;
      &lt;p:input port=&quot;parameters&quot;&gt;&lt;p:inline&gt;&lt;c:param-set/&gt;&lt;/p:inline&gt;&lt;/p:input&gt;
      &lt;p:input port=&quot;query&quot;&gt;
         &lt;p:inline&gt;
            &lt;c:query&gt;
               element groups {
                  let $month := xs:string(/request/@month)
                     for $day in (xs:int(/request/@start) to xs:int(/request/@end))
                        let $date := concat($month,&quot;-&quot;,if ($day &amp;lt; 10) then concat(&quot;0&quot;,$day) else $day),
                            $start := xs:dateTime(concat($date,&quot;T00:00:00Z&quot;))
                           for $h in (0 to 23)
                              let $hstart := $start + xs:dayTimeDuration(concat(&quot;PT&quot;,$h,&quot;H&quot;)),
                                  $hend := $hstart + xs:dayTimeDuration(&quot;PT1H&quot;)
                                  return element group {
                                     attribute date { $date },
                                     attribute start { $hstart },
                                     attribute end { $hend }
                                  }
               }
         &lt;/c:query&gt;
         &lt;/p:inline&gt;
      &lt;/p:input&gt;
   &lt;/p:xquery&gt;

</code></pre>
<p>Now we just use the viewporting mechanism of XProc to handle each group separately:</p>
<pre><code>
   &lt;p:viewport match=&quot;/groups/group&quot;&gt;
      &lt;!-- output a message to the console --&gt;
      &lt;cx:message&gt;
         &lt;p:with-option name=&quot;message&quot; 
                        select=&quot;concat('Processing ',/group/@date,' from ',/group/@start,' to ',/group/@end)&quot;/&gt;
      &lt;/cx:message&gt;
      &lt;!-- generate the query to send --&gt;
      &lt;p:template&gt;
         &lt;p:input port=&quot;parameters&quot;&gt;&lt;p:inline&gt;&lt;c:param-set/&gt;&lt;/p:inline&gt;&lt;/p:input&gt;
         &lt;p:input port=&quot;template&quot;&gt;
            &lt;p:inline&gt;
               &lt;c:query&gt;
                  declare namespace s=&quot;http://weather.milowski.com/V/APRS/&quot;;
                  element collection-set {{
                     attribute date {{ &quot;{string(/group/@date)}&quot; }},
                     let $dtstart := xs:dateTime(&quot;{string(/group/@start)}&quot;),
                         $dtend := xs:dateTime(&quot;{string(/group/@end)}&quot;),
                         $count := xdmp:estimate(
                             collection(&quot;http://weather.milowski.com/weather/&quot;)
                                /s:report[@received &gt;= $dtstart and @received &amp;lt;$dtend]),
                         $set := collection(&quot;http://weather.milowski.com/weather/&quot;)
                                    /s:report[@received &gt;= $dtstart and @received &amp;lt;$dtend]
                         return (
                           attribute start {{ &quot;{string(/group/@start)}&quot; }},
                           attribute end {{ &quot;{string(/group/@end)}&quot; }},
                           attribute count {{ $count }},
                           for $d in $set
                              return 
                                 xdmp:document-add-collections(
                                    base-uri($d),
                                    (&quot;http://weather.milowski.com/weather/{string(/group/@month)}&quot;,
                                     &quot;http://weather.milowski.com/weather/{string(/group/@date)}&quot;)) 
                        )
                  }}
               &lt;/c:query&gt;
            &lt;/p:inline&gt;
         &lt;/p:input&gt;
      &lt;/p:template&gt;
      &lt;!-- send the query to the server --&gt;
      &lt;ml:adhoc-query&gt;
         &lt;p:with-option name='user' select='$xdb.user'/&gt;
         &lt;p:with-option name='password' select='$xdb.password'/&gt;
         &lt;p:with-option name='host' select='$xdb.host'/&gt;
         &lt;p:with-option name='port' select='$xdb.port'/&gt;
         &lt;p:input port=&quot;parameters&quot;&gt;&lt;p:inline&gt;&lt;c:param-set/&gt;&lt;/p:inline&gt;&lt;/p:input&gt;
      &lt;/ml:adhoc-query&gt;
   &lt;/p:viewport&gt;

</code></pre>
<p>If you've stuck with me this far, you've just seen a whole lot of XProc but understanding the steps isn't that bad once you get used to it:</p>
<ul>
<li>The <code>p:viewport</code> matches each <code>group</code> element and makes it a separate document that is processed by the steps it contains.</li>
<li>The very first <code>cx:message</code> step just outputs a console message so we can see the progress.</li>
<li>The <code>p:template</code> step generates a query based on the group element.  The syntax replaces constructs within curly braces with the expression results.  You can see that the mixing of <code>p:template</code> and XQuery is a bit confusing as they both use curly brackets in their syntax.</li>
<li>Finally, the <code>ml:adhoc-query</code> step receives the results from the <code>p:template</code> step and sends it to the server to be executed.  If all goes well, a single <code>collection-set</code> element is returned by the query with data about how many documents were processed.</li>
</ul>
<p>The output of the pipeline is just a <code>groups</code> element with a set of <code>collection-set</code> element children detailing what hours and counts of documents that were processed.</p>
<h3>Back to Deleting Those Documents!</h3>
<p>The delete of data by month is accomplished via XProc in a similar way.  The full pipeline is listed below:</p>
<pre><code>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;p:declare-step 
   xmlns:p=&quot;http://www.w3.org/ns/xproc&quot;
   xmlns:c=&quot;http://www.w3.org/ns/xproc-step&quot; 
   xmlns:ml=&quot;http://xmlcalabash.com/ns/extensions/marklogic&quot;
   version=&quot;1.0&quot;&gt;
   &lt;p:option name='xdb.user'/&gt;
   &lt;p:option name='xdb.password'/&gt;
   &lt;p:option name='xdb.host'/&gt;
   &lt;p:option name='xdb.port'/&gt;
   &lt;p:input port=&quot;source&quot;&gt;
      &lt;p:inline&gt;
         &lt;request month=&quot;2013-01&quot; start=&quot;1&quot; end=&quot;31&quot;/&gt;
      &lt;/p:inline&gt;
   &lt;/p:input&gt;
   &lt;p:output port=&quot;result&quot;/&gt;
   &lt;p:import href=&quot;http://xmlcalabash.com/extension/steps/library-1.0.xpl&quot;/&gt;
   
   &lt;p:xquery&gt;
      &lt;p:input port=&quot;parameters&quot;&gt;&lt;p:inline&gt;&lt;c:param-set/&gt;&lt;/p:inline&gt;&lt;/p:input&gt;
      &lt;p:input port=&quot;query&quot;&gt;
         &lt;p:inline&gt;
            &lt;c:query&gt;
               element days {
                  let $month := xs:string(/request/@month)
                     for $n in reverse(xs:int(/request/@start) to xs:int(/request/@end))
                        return element day { 
                           attribute month { $month },
                           attribute day { if ($n &amp;lt; 10) then concat(&quot;0&quot;,$n) else $n }
                        }
               }
         &lt;/c:query&gt;
         &lt;/p:inline&gt;
      &lt;/p:input&gt;
   &lt;/p:xquery&gt;
   &lt;p:viewport match=&quot;/days/day&quot;&gt;
      &lt;p:template&gt;
         &lt;p:input port=&quot;parameters&quot;&gt;&lt;p:inline&gt;&lt;c:param-set/&gt;&lt;/p:inline&gt;&lt;/p:input&gt;
         &lt;p:input port=&quot;template&quot;&gt;
            &lt;p:inline&gt;
            &lt;c:query&gt;
               declare namespace s=&quot;http://weather.milowski.com/V/APRS/&quot;;
               let $date :=  &quot;{string(/day/@month)}-{string(/day/@day)}&quot;,
                   $collection := concat(&quot;http://weather.milowski.com/weather/&quot;,$date)
                  return
                     element deleted {{
                        attribute date {{ $date }},
                        attribute count {{ xdmp:estimate(collection($collection)/s:report) }},
                        xdmp:collection-delete($collection)
                     }}
            &lt;/c:query&gt;
            &lt;/p:inline&gt;
         &lt;/p:input&gt;
      &lt;/p:template&gt;
      &lt;ml:adhoc-query&gt;
         &lt;p:with-option name='user' select='$xdb.user'/&gt;
         &lt;p:with-option name='password' select='$xdb.password'/&gt;
         &lt;p:with-option name='host' select='$xdb.host'/&gt;
         &lt;p:with-option name='port' select='$xdb.port'/&gt;
         &lt;p:input port=&quot;parameters&quot;&gt;&lt;p:inline&gt;&lt;c:param-set/&gt;&lt;/p:inline&gt;&lt;/p:input&gt;
      &lt;/ml:adhoc-query&gt;
   &lt;/p:viewport&gt;
   
&lt;/p:declare-step&gt;
</code></pre>
<p>Enough XProc for you?  I've got more...</p>

</article>
